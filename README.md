![Project Logo](https://github.com/mxmknnv/shri-2018-entrance-task-3/blob/master/screenshots/logo.png)
# Приложение для создания и редактирования информации о встречах сотрудников (back-end)
*** Полная версия загружена на heroku и доступна [онлайн](https://shri-2018.herokuapp.com/). ***

Написано для Node.js 8 и использует библиотеки:
* express
* sequelize
* graphql

## Задание
Код содержит ошибки разной степени критичности. Некоторых из них стилистические, а некоторые даже не позволят вам запустить приложение. Вам необходимо найти и исправить их.

Пункты для самопроверки:
1. Приложение должно успешно запускаться
2. Должно открываться GraphQL IDE - http://localhost:3000/graphql/
3. Все запросы на получение или изменения данных через graphql должны работать корректно. Все возможные запросы можно посмотреть во вкладке Docs в GraphQL IDE или в схеме (typeDefs.js)
4. Не должно быть лишнего кода
5. Все должно быть в едином codestyle

## Запуск
```
npm i
npm run start
```

Для сброса данных в базе:
```
npm run reset-db
```
## Тестирование
```
npm run start-test
npm run test
```

Для сброса данных в тестовой базе:
```
npm run reset-db-test
```

## Решение

### 1. Запуск приложения.
При первом запуске приложения в консоли появилась ошибка. Текст ошибки и стек вызовов указывал на то, что ошибка связана с библиотекой Sequelize, а именно с конструктором, который вызывается в файле `models/index.js`. Необходимо проверить аргументы, которые передаются при инициализации. Для справки я использовал [официальную документацию](http://docs.sequelizejs.com/manual/installation/usage.html#basic-usage). Существует несколько форматов передачи аргументов в конструктор Sequelize: в виде 4-х отдельных аргументов или в виде объекта, содержащего соответствующие свойства. Ошибка вызвана тем, что один из обязательных аргументов был пропущен. Необходимо восстановить формат, добавив еще один аргумент (password) перед options. После внесенных изменений приложение успешно запускается, и по адресу `http://localhost:3000/` отображается страница с приветствием.

### 2. Страница с GraphQL IDE.
После запуска приложения на странице по адресу `http://localhost:3000/graphql/` отображалось стандартное сообщение Express о том, что искомый маршрут не доступен. Первым делом, я предположил ошибку аналогичную ошибке из 1-го пункта и проверил, что обработчик express-graphql сконфигурирован должным образом. За информацией я обратился к [официальной документации](https://github.com/graphql/express-graphql) и проверил код в файле `graphql/routes.js`, но не обнаружил причину проблемы. Следующим шагом, я решил проследить весь путь "роутинга" с самого начала и обнаружил ошибку в файле `index.js`. Да, проблема заключалась в банальной опечатке (*graphgl* вместо *graphql*).

### 3. Тестирование.

Следующим шагом, мне предстояло проверить корректность работы все методов через GraphQL IDE, в сумме это 18 запросов: 6 простых (query) и 12 сложных (mutation). Каждый раз при внесении серьезных изменений в код, необходимо будет проверить корректность работы всех этих методов еще один раз! В качестве бонусного задания предлагается написать тесты к реализованной функциональности, поэтому я решил, что наиболее оптимально сразу приступить к написанию тестов, параллельно проверяя работу методов. В качестве инструмента для тестирования я выбрал Jest.

#### Unit vs Integration тестирование

При выборе метода для тестирования приложения я исходил из конкретной задачи. Логика работы отдельных элементов системы достаточно проста, поэтому нет необходимости тестировать каждый такой элемент в отдельности. В большей степени необходимо убедиться в правильном взаимодействии всех этих элементов. Для решения этой задачи я решил пойти по пути интеграционного тестирования:
1. Методы вызываются с помощью http запроса. Для этих целей я использую стандартный модуль *Request* и *request-promise-native* для поддержки promises.
2. Результат работы каждого метода проверяется напрямую через БД. В целях безопасности для тестирования используется отдельна БД, таким образом я исключаю возможность повредить production данные. Кроме этого, для каждой интерации тестов тестовая БД будет обновлять
ся и заполняться автоматически сгенерированными mock-данными.

#### Пример

Тесты разбиты на три файла, для проверки методов работающих с сущностями User, Room и Event соответственно. В файл `tools.js` вынесены вспомогательные функции. Для примера, разберем структуру теста для метода createEvent:
1. Конструирование и отправка запроса. Для составления тела запроса используется шаблонная строка. Все составные части для удобства вынесены в отдельные константы: EVENT_TO_CREATE, EVENT_USER_IDS_TO_CREATE, EVENT_ROOM_ID_TO_CREATE.
2. Проверка записи в БД. После того, как ответ получен, скрипт обращается напрямую к БД, используя id созданного события. Проверяется соответствие полученных в ответе данных с информацией непосредственно из БД. Для успешного сравнения, ответ, полученный от Sequelize необходимо нормализовать, а так же отдельно запросить поля users и room. Подготовкой объекта для сравнения занимается функция convertRawEventSample.
3. Сравнение полученных данных с образцом. Полученный в ответе объект Event сравнивается с образцом (EVENT_TO_CREATE), согласно которому составлялся запрос. Отдельно сравниваются поля users (EVENT_USER_IDS_TO_CREATE) и room (EVENT_ROOM_ID_TO_CREATE). Для того, чтобы сохранить гибкость, я не стал задавать все поля объектов User и Room. Сравниваются только поля id.

<details>
 <summary>Тест для метода createEvent</summary>
 
 ```
 test('Mutation: createEvent', async () => {
    const QUERY = `
      mutation {
        createEvent(
          input: {
            title: "${EVENT_TO_CREATE.title}",
            dateStart: "${EVENT_TO_CREATE.dateStart}",
            dateEnd: "${EVENT_TO_CREATE.dateEnd}"
          },
          usersIds: [${EVENT_USER_IDS_TO_CREATE}],
          roomId: ${EVENT_ROOM_ID_TO_CREATE}
        ) ${EVENT_QUERY_BODY}
      }
    `;

    const rawData = await graphqlQuery(QUERY);
    const data = rawData.data.createEvent;

    // Проверяем, есть ли соответствующая запись в базе данных

    const rawSample = await models.Event.findById(data.id);
    const sample = await convertRawEventSample(rawSample);

    expect(data).toEqual(sample);

    // Проверяем соответствие id для users and room
    // Другие поля будем игнорировать

    const USER_IDS_TO_COMPARE = data.users.map(user => Number(user.id));
    expect(USER_IDS_TO_COMPARE).toEqual(EVENT_USER_IDS_TO_CREATE);

    const ROOM_ID_TO_COMPARE = Number(data.room.id);
    expect(ROOM_ID_TO_COMPARE).toEqual(EVENT_ROOM_ID_TO_CREATE);

    // Проверяем, соответствуют ли полученные данные оригинальному образу EVENT_TO_CREATE

    EVENT_ID_TO_TEST = data.id;

    delete data.id;
    delete data.users;
    delete data.room;

    expect(data).toEqual(EVENT_TO_CREATE);
  });
 ```
</details>

### 4. Добавление нового метода eventsByDate

По умолчанию для получения списка событий доступен только один метод events, этот метод возвращает список всех (!) событий в БД, без возможности фильтрации. Для того, чтобы понять проблему, посчитаем примерное количество событий, которое будет храниться в БД после 1-го года использования приложения. Для подсчетов представим следующие ограничения: в организации 10 переговорок, каждая из которых используется 3/4 доступного времени (с 8 до 23 часов), средняя продолжительность встречи 1 час, переговорки используются только по рабочим дням (будем считать, что в 1 месяце 21 рабочий день). Получим, что через 1 год на сервере будет **27'720** записей Events. Передача такого кол-во данных клиенту в ответ на самый обычный запрос является, мягко говоря, не оптимальной.

Самый естественный способ решить вышеописанную проблему - добавить в метод фильтрацию по дате.

<details>
 <summary>Метод eventsByDate</summary>
 
 ```
 eventsByDate: (root, { date }, { Event }) => {
    const start = new Date(date);
    const end = new Date(date);

    start.setHours(0, 0, 0, 0);
    end.setHours(24, 0, 0, 0);

    return Event.findAll({
      where: {
        dateStart: {
          [Op.between]: [start, end],
        },
        dateEnd: {
          [Op.between]: [start, end],
        },
      },
    });
  },
 ```
</details>

### 5. Модификация метода updateEvent

Заданный по умолчанию набор методов для изменения объекта Event (updateEvent, addUserToEvent, removeUserFromEvent, changeEventRoom) не является удобным на практике. Метод updateEvent может изменить поля title, dateStart, dateEnd. Методы addUserToEvent и removeUserFromEvent могут добавить или удалить к указанному Event только один (!) userId за один раз. А метод changeEventRoom может изменить установленный roomId.

Для примера, рассмотрим ситуацию, когда пользователь редактирует существующий Event. Пользователь добавил 5 новых участников и 2 участника удалил. Для того, чтобы сохранить изменения на сервере необходимо:
1. Точно знать какие userId новые, а какие userId были помечены для удаления. Если на стороне клиента список участников содержится в простом массиве, то отследить вышеуказанные изменения будет не просто. Необходимо добавлять дополнительную логику и усложнить код.
2. Выполнить все необходимые запросы по очереди: 5 запросов addUserToEvent и 2 запроса removeUserFromEvent.

Для того, чтобы решить описанную проблему я модифицировал updateEvent:
1. Метод отвечает за изменение всех полей объекта Event. Не важно какие поля изменил пользователь - достаточно вызвать один метод для сохранения изменений на сервере.
2. Для изменения списка участников достаточно указать один актуальный массив с userId.

<details>
 <summary>Метод updateEvent "до"</summary>
 
 ```
 updateEvent (root, { id, input }, context) {
    return models.Event.findById(id)
            .then(event => {
              return event.update(input);
            });
  },
 ```
</details>

<details>
 <summary>Метод updateEvent "после"</summary>
 
 ```
 updateEvent(root, { id, input, usersIds, roomId }, { Event }) {
    return Event.findById(id)
      .then(event => event.update(input))
      .then(event => Promise.all([
        event.setUsers(usersIds),
        event.setRoom(roomId),
      ])
        .then(() => event));
  },
 ```
</details>
 
### 6. Рефакторинг

#### package.json

Рефакторинг проекта я решил начать с анализа файла package.json: 
1. Все пакеты обновлены до последних версий.
2. Пакет semistandard удален и заменен на eslint. Для Eslint я использую набор правил от Airbnb. Можно назвать это личным предпочтением, с одинаковым успехом можно было воспользоваться любым другим инструментом для проверки code style.
3. Для я тестирования установлены jest, request, request-promise-native. Подробней о тестировании в 3-ем пункте.
4. Добавлены дополнительные скрипты.

#### index.js

1. Удалено использование модуля body-parser. GraphQL не нуждается в предварительной обработке запросов.
2. Добавлена возможность установить номер порта используя переменную окружения.

#### create-mock-data.js

1. Значительно (!) усовершенствован код для автоматической генерации mock-данных. Все генерируемые данные можно гибко настраивать.

#### graphql

##### graphql/typeDefs.js

1. Удалено объявление "union SearchResult", после объявления этот union нигде не используется.
2. Удалено объявление "type UserRoom", после объявления этот type нигде не используется.
3. Переименовано поле homeFloor на floor, поле avatarUrl на avatar. Я считаю хорошей практикой в программировании придерживаться одного стиля именования переменных, свойств объектов и т.д. Таким образом, в будущем (например, при разработке клиентской части) не возникнет путаницы в чем различие между homeFloor и floor.
4. Установлены обязательными (!) поля для многих объектов, там где такая установка отсутствовала. А так же добавлены отсутствующие поля, например для объекта UserInput, где отсутствовало поле avatar.
5. Изменен синтаксис экспорта для соответствия с общим code style.

##### graphql/routes.js

1. Добавлено поле context в объект конфигурации модуля graphqlHTTP(express-graphql). Таким образом объект models будет передаваться обработчикам запросов (resolvers) автоматически, в виде третьего аргумента функции. Преимуществом такого способа передачи models является то, что импортируем мы его только в одном месте, в самом файле routes.js.

##### graphql/resolvers/index.js

1. Изменена структура функций-обработчиков для полей объекта Event: users & room. Во-первых, в своем первоначальном виде, из-за ошибки в синтаксисе, они вообще не выполняли своей прямой обязанности - они не возвращали никакого значения. Во-вторых, для того, чтобы функции не затирали уже существующие значения, я использовал логический оператор ||.
2. Убрана обертка в виде функции resolvers, теперь из модуля напрямую экспортируется объект.

##### graphql/resolvers/query.js

1. Удален импорт объекта models, код функций изменен для использования аргумента context по своему прямому назначению. Код всех функций очень простой, поэтому синтаксис изменен на стрелочные для большей компактности и наглядности.
2. Изменен синтаксис экспорта для соответствия с общим code style.

##### graphql/resolvers/mutation.js

1. Удален импорт объекта models, код функций изменен для использования аргумента context по своему прямому назначению.
2. Добавлен отсутствующий обработчик для метода addUserToEvent.
3. Код некоторых функций (addUserToEvent, removeUserFromEvent, changeEventRoom) изменен таким образом, чтобы возвращать результат (объект event) только после выполнения асинхронных методов для работы с БД. Таким образом, получится избежать ситуаций, когда функция возвращает клиенту "старую версию" объекта Event. Такое поведение было замечено в работе функции addUserToEvent: при выполнении метода addUserToEvent клиент в ответ получал "старый" список пользователей у объекта Event. Для остальных функций изменения были внесены в целях профилактики.
4. Значительно изменена логика работы функции removeEvent. В первоначальном виде, при выполнении метода removeEvent, в ответ клиент получал пустой массив users у объекта Event. Такое поведение вызвано тем, что после удаления соответствующей записи в БД, нарушается работа метода getUsers у связанного с записью объекта event. Таким образом, в первоначальном виде, после выполнения функции removeEvent, функция-обработчик для поля users объекта Event в файле graphql/resolvers/index.js не могла получить настоящий список users и возвращала пустой объект. Для решения проблемы, перед удалением записи в БД, я заранее "собираю" объект ответа.
5. Изменен синтаксис экспорта для соответствия с общим code style.

#### models

##### models/index.js

1. Удалено объявление Operators Aliases, после объявления операторы нигде не используются.
2. Добавлено условие для автоматического выбора db-test.sqlite3 в качестве файла БД в тестовом режиме (NODE_ENV=test).
3. Изменен синтаксис экспорта для соответствия с общим code style.

##### models/scheme.js

1. Добавлено явное указание разрешенных значений для каждого поля таблиц (кроме Date, которое в достаточной степени проверяется модулем GraphQL). Cвязка sequelize & sqlite3 по-умолчанию позволяет записывать значения, выходящие за рамки установленных ограничений для определенного типа. Например, ничто не мешает записать в поле с типом UNSIGNED TINYINT число превышающее 255. Таким образом, после явного указания ограничений sequelize в тандеме с graphql обеспечивает автоматическую валидацию получаемых от клиента данных: по структуре, по типу, по значению. GraphQL в свою очередь, в ответе корректно отображает ошибку.
2. Удален необязательный оператор return.
